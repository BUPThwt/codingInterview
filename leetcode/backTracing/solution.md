[TOC]
# 思路

## 77 组合 

### 递归函数返回值及参数
result作为入参传入，返回为空即可
因为不能重复，入参中要加入startIndex，并且backTracing时，startIndex要加一

### 确定终止条件
当路径个数等于k时，加入结果集，并终止

### 单层搜索过程
从startIndex开始进行遍历

### 剪枝
当剩余遍历个数不足需要添加的个数时，即不满足， n - (k - path.size()) + 1
+1是因为要包含当前的值

## 216 组合总和
### 递归函数返回值及参数
result作为入参传入，返回为空即可
因为不能重复，入参中要加入startIndex，并且backTracing时，startIndex要加一
和为n，可以使用差值进行传递，所以省略sum这个参数

### 确定终止条件
当目标值n为负数时，结束。
当路径个数等于k时，且目标值为0时，加入结果集，并终止

### 单层搜索过程
从startIndex开始进行遍历

### 剪枝
- 当剩余遍历个数不足需要添加的个数时，即不满足， n - (k - path.size()) + 1，+1是因为要包含当前的值
- for循环中加入n和i的判断，如果n< i 则后面的数均不需要遍历

## 17 电话号码的字母组合

### 准备

使用全局数组map对应0-9这10个数字对应的英文。

### 递归函数返回值及参数
result作为入参传入，返回为空即可
使用startIndex来记录遍历了digits的第几个数。

### 确定终止条件
当遍历的startIndex和digits长度相等，即所有的数字都遍历完，加入结果集并终止。

### 单层搜索过程
通过startIndex从map中获取当前数字对应的字母集。
对字母集从0开始遍历，因为对startIndex那一层进行赋值，会覆盖，所以只需要赋值，不需要回退。

### 剪枝
没有剪枝内容。


## 40 组合总和2
### 准备
因为需要去重，而且是组合没有顺序，所以需要对数组进行排序。

### 递归函数返回值及参数
result作为入参传入，返回为空即可
因为不能重复，入参中要加入startIndex，并且backTracing时，startIndex要加一
这里涉及到树层去重，所以引入used数组，判断数字是否在之前层使用过。
如果两个数相等，前一个数字的选择会比后一个数字的选择范围更广，所以后一个数字在这一层不需要选择，表达式为 i > 0 && candidates[i] == candidates[i - 1] && !used[i - 1]

### 确定终止条件
当目标值target为负数时，结束。
当路径个数等于k时，且目标值target为0时，加入结果集，并终止

### 单层搜索过程
从startIndex开始进行遍历,对和前一个数字相等的数字不做处理。递归式传递剩余值

### 剪枝
- 当target小于候选值时，已经不能凑成和target,所以不需要在进行回溯。


## 39 组合总和

### 递归函数返回值及参数
result作为入参传入，返回为空即可
因为是同一数组中遍历，入参中要加入startIndex
因为一个元素可以重复取，所以递归中startIndex不需要加1，当前元素可以重复取多次。

### 确定终止条件
当目标值target为0，就是之前路径的和等于target时就终止，加入结果集。

### 单层搜索过程
从startIndex开始进行遍历,对和前一个数字相等的数字不做处理。递归式传递剩余值
因为每个元素可以重复取，所以入参startIndex传的是当前的i，不需要加1

### 剪枝
- 当target小于候选值时，已经不能凑成和target,所以不需要在进行回溯。注意因为加了这个剪枝条件，需要对数组进行排序，否则乱序数组中后面小的且满足条件的元素无法遍历到。

## 131 分割回文字符串

### 递归函数返回值及参数
result作为入参传入，返回为空即可
因为是同一数组中遍历，入参中要加入startIndex，因为不能重复分割，所以starIndex要+1

### 确定终止条件
当遍历的index和字符串长度一样的时候就结束，添加到结果集。

### 单层搜索过程
从startIndex开始进行遍历,判断如果是回文字符串的话就进行回溯，如果不是会玩字符串就继续遍历，确保了只有回文字符串会进入回溯流程。

### 剪枝
- 没有剪枝


## 93 复原IP地址

### 递归函数返回值及参数
result作为入参传入，返回为空即可
因为是同一数组中遍历，入参中要加入startIndex，因为不能重复分割，所以starIndex要+1
一个ip有4个段，需要传入参数left，表示剩余多少个段需要切割。

### 确定终止条件
当startIndex遍历到数组长度，即结尾处，而此时剩余分割数量left为0，则添加到结果集，并返回。

### 单层搜索过程
从startIndex开始进行遍历,因为每段最多是个三位数，所以小于startIndex+3，如果i大于字符串长度，就返回，
如果截取的段符合ip段要求，就进行回溯。

校验单个ipsegment是否有效
- 如果长度不是1位，就不能以0开头
- 将字符串转换为数字，然后判断是否在0-255闭区间内

### 剪枝
- 回溯前先判断字符串长度是否在4-12闭区间内
- 单层搜索中只搜索starindex后的3位



## 78 子集

### 递归函数返回值及参数
result作为入参传入，返回为空即可
因为是同一数组中遍历，入参中要加入startIndex，因为子集中元素不能重复，所以starIndex要+1


### 确定终止条件
子集是收集所有树上的节点，没有终止条件，每一次回溯都需要把路径节点加到结果里。

### 单层搜索过程
从startIndex开始遍历，然后进行回溯。


### 剪枝
每个节点都要加入到结果集，所以不需要剪枝


## 491 递增子序列

### 递归函数返回值及参数
result作为入参传入，返回为空即可
因为是同一数组中遍历，入参中要加入startIndex，因为子集中元素不能重复，所以starIndex要+1


### 确定终止条件
没有终止条件，当个数大于等于2时，就是一个满足条件的递增子序列，所以只需判断size大于等于2就加入结果集。

### 单层搜索过程
此处要做同层去重，在本层backTracing时要记录某个数是否已经使用，因为大小范围为-100到100，可以设置一个大小为201的数组，记录本层该数是否使用过，只在本层使用，不传递。

for循环中，判断如果当期数比上一个数还小就跳过，或者当前数为之前使用过的，就去掉。 

去重的逻辑是，两个数相等，前一个数的选择范围比后一个数大，所以只要前一个出现过，本层就不再选第二个了。


### 剪枝
没有剪枝


## 46 全排排列

### 准备
排列是有序的，所以是可以重复的，需要记录元素是否使用过。

### 递归函数返回值及参数
result作为入参传入，返回为空即可



### 确定终止条件
因为是排列，就是对数组进行排序，数组中不重复，所以只要路径节点数和数组节点数一致时，就加入结果集返回。

### 单层搜索过程
每一层都从0开始遍历整个数组，判断到使用过就跳过，没使用过就开始回溯。


### 剪枝
没有剪枝



## 47 全排排列2

### 准备
排列是有序的，所以是可以重复的，需要记录元素是否使用过。
但是因为元素是有重复的，所以需要去重，使用树层去重。
树层去重和树枝去重是个重要的概念，使用布尔型的数组可以表示。
两个数相等的情况下，used[i - 1]== true，证明本路径上使用过，
used[i - 1]==false,证明本层已经使用过。

### 递归函数返回值及参数
result作为入参传入，返回为空即可
是求排列，排列可以重复，讲究顺序，需要记录数字是否使用过。需要使用used记录。
### 确定终止条件
因为是排列，就是对数组进行排序，当数组长度和路径path长度相等时，就加入结果集。

### 单层搜索过程
每一层都从0开始遍历整个数组，判断到使用过就跳过，没使用过就开始回溯。
要做同层去重：
- 第一种方法是使用used表示元素是否使用过，用layerUsed记录同层是使用过。
- 第二种方法，使用一个used数组记录，两个数相等的情况下，used[i - 1]== true，证明本路径上使用过，
used[i - 1]==false,证明本层已经使用过。


### 剪枝
没有剪枝



## 90 子集2

### 准备
求子集，包括本身及空子集，需要对数组进行排序；
因为可能包含重复数，所以需要同层去重，也就是树层去重。

### 递归函数返回值及参数
result作为入参传入，返回为空即可
对同一个数组找子集，子集不能重复，前面的参数不能再取，所以需要设置startIndex
### 确定终止条件
求子集，是求树上的每一个节点，所以每一次回溯都可以添加。

### 单层搜索过程
每一层从startIndex开始遍历，符合条件就回溯；
因为需要做同层去重，而且数组经过排序，所以可以判断是否和前一个数字相等，若相等则不可再取，注意要使用i > startIndex。避免出现树枝去重。


### 剪枝
没有剪枝

## 332 重新安排行程

太难了，还需要理解 

### 理解
机票可以理解为有向图，使用map来维护当前机场可以飞到其他机场的信息，因为有多个机场时，需要返回字典顺序的路径，可以使用贪心思想，当前机场相邻的机场使用小顶堆去维护。

回溯方法中，有图信息，有起始机场，有结果集。

首先获取当前机场的相邻机场，如果相邻机场非空就逐个从小顶堆中取出，然后进行回溯。

使用头插法，当首先出现没有临近机场可用的机场src会先入到链表中，然后是上一个机场，最后是JFK机场。【此处很难理解，但是很妙】

### 摘抄
- 如果按照字典顺序输出，我们 优先访问字典顺序小的节点ATL即可。因此，我们 使用贪心策略，优先访问字典顺序小的顶点
- 当我们采用 DFS 方式遍历图时，需要将访问到的节点逆序插入到结果集。因此第一个访问到的节点将出现在结果集最后面，而我们是以顺序的方式来查看结果。如果第一个访问的节点是 “孤岛节点”，他会出现在结果集的最后。当我们顺序读取结果集时，这种 “孤岛节点” 是最后遇到的，是图遍历的终点，这样就没有问题了。



## 51 N皇后

### 准备
N皇后，棋盘上Q代表皇后，.代表空格，皇后会攻击同行，同列和斜对角的皇后。
皇后是一层一层放的，所以只要考虑上一层的就行。

### 递归函数返回值及参数
n*n的棋盘，当前放的行数，以及结果result，作为入参进行回溯。
### 确定终止条件
当行数和棋盘的n相等时，就是一种合理的摆放方式，可以加入结果集。

### 单层搜索过程
每一层先进行校验，可行的话就放Q，然后回溯
校验规则：
- 同列不能有Q
- 左斜上角上不能有Q
- 右斜上角上不能有Q


### 剪枝
没有剪枝

## 37 解数独

### 准备
方法入参是棋盘，重写backtracing方法，
backtracing类似于一个下棋的过程，从左往右，从上至下

### 递归函数返回值及参数
backtracing返回true，证明这步棋是对的。返回false则是回退。
### 确定终止条件
没有终止条件，棋盘遍历完就结束。

### 单层搜索过程
从左往右，从上至下放数字，如果当前格子有数字了，则跳过，当前格子没有数字就开始放数字，放数字从1到9开始尝试，如果数字与棋盘上其他数字校验通过就放当前值，然后继续放棋子（回溯，backtracing）.如果返回false，就置为空格，尝试其他的数字，当9个数字都尝试失败时，返回false，回退到上一格的棋盘。
如果摆放最后一个棋子都没有问题，则返回true，即所有棋格都下完了，然后一层一层都返回true,表示之前的棋子摆放都没问题。


### 校验规则valid
- 同行不能已经有相同数字，
- 同列不能已经有相同数字
- 所在的9格子里不能有相同数字。

所在的小格子里，可以使用startRow， starCol表示，除3再乘3，转到初始位置。


### 剪枝
没有剪枝













